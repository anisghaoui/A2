#include <stdio.h>
#include "block_matrix.h"
#include <time.h>
#include "xparameters.h"
#include "xmultiply_block.h"
#include "sleep.h"
#include "xil_cache.h"
#include "xtime_l.h"


void init_multiply_block_ip(XMultiply_block* mb,XMultiply_block_Config* mb_c){

	//int status=XMultiply_block_Initialize(mb,id);
	int status=XMultiply_block_CfgInitialize(mb,mb_c);
	XMultiply_block_DisableAutoRestart(mb);
	XMultiply_block_InterruptGlobalDisable(mb);
	XMultiply_block_InterruptDisable(mb, 1);
	if(status!=XST_SUCCESS){
		printf("Multiply Block: init_failed\n");
	}
	printf("idle=%lx,ready=%lx,done=%lx\n",XMultiply_block_IsIdle(mb),XMultiply_block_IsReady(mb),XMultiply_block_IsDone(mb));
	printf("succes\n");
}




void multiply_block_hw_call(XMultiply_block* mb_p,type* mA, type* mB, type* result){


	//Xil_DCacheDisable();
	XMultiply_block_Set_in_mA(mb_p, (u32)mA);
	XMultiply_block_Set_in_mB(mb_p, (u32)mB);
	XMultiply_block_Set_out_mC(mb_p, (u32)result);
	Xil_DCacheFlush();
	//printf("in out set:\n");
	//printf("ma:%X=>%X,mb:%X=>%X,mc:%X=>%X\n",(u32)mA,XMultiply_block_Get_in_mA(mb_p),(u32)mB,XMultiply_block_Get_in_mB(mb_p),(u32)result,XMultiply_block_Get_out_mC(mb_p));
	//printf("waiting ready\n");
	while(!XMultiply_block_IsReady(mb_p));
	//printf("multiply is ready\n");
	XMultiply_block_DisableAutoRestart(mb_p);
	XMultiply_block_Start(mb_p);
	//printf("waiting résult\n");
	while(!XMultiply_block_IsDone(mb_p)){
		//sleep(1);
		//printf("status:idle=%lx,ready=%lx,done=%lx\n",XMultiply_block_IsIdle(mb_p),XMultiply_block_IsReady(mb_p),XMultiply_block_IsDone(mb_p));
	}
	//printf("finished\n");
	Xil_DCacheFlushRange(result,M*N*sizeof(float));
	//printf("status:idle=%lx,ready=%lx,done=%lx\n",XMultiply_block_IsIdle(mb_p),XMultiply_block_IsReady(mb_p),XMultiply_block_IsDone(mb_p));
	//les résultat sont au bonne endroit
	return;

}


type A[M][P];
type B[P][N];
type result[M][N];

int block_matrix_test()
{
	XMultiply_block MB;
	XMultiply_block_Config mb_c ={0,XPAR_MULTIPLY_BLOCK_0_S_AXI_CONTROL_BUS_BASEADDR};
	XTime Start_Time, End_Time, ExecTimeInTicks;
	printf("init multiply block2\n");
	init_multiply_block_ip(&MB,&mb_c);
	printf("init data\n");
	int i,j,k;


    for ( i = 0; i < M; i++) ///0, 1,2,3,4,5,6,7...
        for ( j = 0; j < P; ++j)
        {
            A[i][j] = P * i + j;
        }

    for ( j = 0; j < P; j++)// 1,1,1,1,1,1...
        for ( k = 0; k < N; ++k)
        {
            B[j][k] = 1;
        }

   for ( i = 0; i < M; i++) /// 0,0,0,0,0,0,
        for ( k = 0; k < N; ++k)
        {
            result[i][k] = 0.1;
        }



    printf("testing block matrix ip\n");
    //clock_t T1 = clock();
    XTime_GetTime((XTime *) &Start_Time);
    multiply_block_hw_call(&MB,(float*)A, (float*)B, (float*)result);
    XTime_GetTime((XTime *) &End_Time);
    //clock_t T2 = clock();

    for (i = 0; i < M; i++) { // should print the same sume value of each line
        for (j = 0; j < N; j++) {
            printf("%f  ", result[i][j]);
        }
        printf("\n");
    }
printf("fin du test\n");
ExecTimeInTicks = End_Time - Start_Time;
double elapsedInUs = 1.0 * (End_Time - Start_Time) / (COUNTS_PER_SECOND/1000000);
printf("(main) ExecTime = %lld unit (%.5f useconds)\n", ExecTimeInTicks,
		elapsedInUs);


    return 0;
}
